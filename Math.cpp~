/*
 * Math.cpp
 *
 *  Created on: Apr 18, 2012
 *      Author: jarl
 */

#include "Math.hpp"

//const samurai::Scalar samurai::ScalarMax = DBL_MAX;
//const samurai::Scalar samurai::PI = M_PI;

samurai::Vector::Vector() :
    x(samurai::ScalarMax), y(samurai::ScalarMax)
{
}
samurai::Vector::Vector(const samurai::Vector& vector) :
    x(vector.x), y(vector.y)
{
}
samurai::Vector::Vector(samurai::Scalar x, samurai::Scalar y) :
    x(x), y(y)
{
}
bool samurai::Vector::valid()
{
    return x != samurai::ScalarMax && y != samurai::ScalarMax;
}
samurai::Vector samurai::Vector::quarterLeft()
{
    return Vector(-y, x);
}
samurai::Vector samurai::Vector::quarterRight()
{
    return Vector(y, -x);
}
samurai::Scalar samurai::Vector::length()
{
    return sqrt(*this * *this);
}
samurai::Scalar samurai::Vector::cross(const samurai::Vector& that)
{
    return x * that.y - y * that.x;
}
samurai::Vector samurai::Vector::unit()
{
    return *this / length();
}
samurai::Vector& samurai::Vector::operator=(const samurai::Vector& that)
{
    x = that.x;
    y = that.y;
    return *this;
}
samurai::Vector& samurai::Vector::operator+=(const samurai::Vector& that)
{
    x += that.x;
    y += that.y;
    return *this;
}
samurai::Vector samurai::Vector::operator+(const samurai::Vector& that)
{
    samurai::Vector result = *this;
    result += that;
    return result;
}
samurai::Vector& samurai::Vector::operator-=(const samurai::Vector& that)
{
    x -= that.x;
    y -= that.y;
    return *this;
}
samurai::Vector samurai::Vector::operator-(const samurai::Vector& that)
{
    samurai::Vector result = *this;
    result -= that;
    return result;
}
samurai::Vector samurai::Vector::operator-()
{
    samurai::Vector result;
    result.x = -x;
    result.x = -x;
    return result;
}
samurai::Vector& samurai::Vector::operator*=(const samurai::Scalar& that)
{
    x *= that;
    y *= that;
    return *this;
}
samurai::Scalar samurai::Vector::operator*(const samurai::Vector& that)
{
    return x * that.x + y * that.y;
}
samurai::Vector& samurai::Vector::operator/=(const samurai::Scalar& that)
{
    x /= that;
    y /= that;
    return *this;
}
samurai::Vector samurai::Vector::operator/(const samurai::Scalar& that)
{
    samurai::Vector result = *this;
    result /= that;
    return result;
}

samurai::Vector operator*(const samurai::Scalar& scalar,
                          const samurai::Vector& vector)
{
    samurai::Vector result = vector;
    result *= scalar;
    return result;
}
samurai::Vector operator*(const samurai::Vector& vector,
                          const samurai::Scalar& scalar)
{
    samurai::Vector result = vector;
    result *= scalar;
    return result;
}

samurai::Matrix::Matrix() :
    ul(samurai::ScalarMax), ll(samurai::ScalarMax), lr(samurai::ScalarMax), ur(samurai::ScalarMax)
{
}
bool samurai::Matrix::valid()
{
    return ul != samurai::ScalarMax && ll != samurai::ScalarMax && lr != samurai::ScalarMax && ur != samurai::ScalarMax;
}
samurai::Matrix::Matrix(samurai::Scalar ul, samurai::Scalar ll,
                        samurai::Scalar ur, samurai::Scalar lr) :
    ul(ul), ll(ll), lr(lr), ur(ur)
{
}
const samurai::Scalar& samurai::Matrix::operator()(const int& row,
        const int& column) const
{
    if (row == 0)
    {
        if (column == 0)
        {
            return ul;
        }
        else
        {
            return ur;
        }
    }
    else
    {
        if (column == 0)
        {
            return ll;
        }
        else
        {
            return lr;
        }
    }
}
samurai::Scalar& samurai::Matrix::operator()(const int& row, const int& column)
{
    if (row == 0)
    {
        if (column == 0)
        {
            return ul;
        }
        else
        {
            return ur;
        }
    }
    else
    {
        if (column == 0)
        {
            return ll;
        }
        else
        {
            return lr;
        }
    }
}
samurai::Matrix& samurai::Matrix::operator=(const samurai::Matrix& that)
{
    ul = that.ul;
    ll = that.ll;
    lr = that.lr;
    ur = that.ur;
    return *this;
}
samurai::Matrix& samurai::Matrix::operator+=(const samurai::Matrix& that)
{
    ul += that.ul;
    ll += that.ll;
    lr += that.lr;
    ur += that.ur;
    return *this;
}
samurai::Matrix samurai::Matrix::operator+(const samurai::Matrix& that)
{
    samurai::Matrix result = *this;
    result += that;
    return result;
}
samurai::Matrix& samurai::Matrix::operator-=(const samurai::Matrix& that)
{
    ul -= that.ul;
    ll -= that.ll;
    lr -= that.lr;
    ur -= that.ur;
    return *this;
}
samurai::Matrix samurai::Matrix::operator-(const samurai::Matrix& that)
{
    samurai::Matrix result = *this;
    result -= that;
    return result;
}
samurai::Matrix samurai::Matrix::operator-()
{
    samurai::Matrix result;
    ul = -ul;
    ll = -ll;
    lr = -lr;
    ur = -ur;
    return result;
}
samurai::Matrix& samurai::Matrix::operator*=(const samurai::Scalar& that)
{
    ul *= that;
    ll *= that;
    lr *= that;
    ur *= that;
    return *this;
}
samurai::Matrix& samurai::Matrix::operator*=(const samurai::Matrix& that)
{
    samurai::Matrix old = *this;
    ul = old.ul * that.ul + old.ur * that.ll;
    ll = old.ll * that.ul + old.lr * that.ll;
    ur = old.ul * that.ur + old.ur * that.lr;
    lr = old.ll * that.ur + old.lr * that.lr;
    return *this;
}
samurai::Vector samurai::Matrix::operator*(const samurai::Vector& that)
{
    samurai::Vector result;
    result.x = ul * that.x + ur * that.y;
    result.y = ll * that.x + lr * that.y;
    return result;
}
samurai::Matrix samurai::Matrix::operator*(const samurai::Matrix& that)
{
    samurai::Matrix result = *this;
    result *= that;
    return result;
}
samurai::Matrix& samurai::Matrix::operator/=(const samurai::Scalar& that)
{
    ul /= that;
    ll /= that;
    lr /= that;
    ur /= that;
    return *this;
}
samurai::Matrix& samurai::Matrix::operator/=(const samurai::Matrix& that)
{
    samurai::Matrix inverted = that.inverse();
    samurai::Matrix old = *this;
    ul = old.ul * inverted.ul + old.ur * inverted.ll;
    ll = old.ll * inverted.ul + old.lr * inverted.ll;
    ur = old.ul * inverted.ur + old.ur * inverted.lr;
    lr = old.ll * inverted.ur + old.lr * inverted.lr;
    return *this;
}
samurai::Scalar samurai::Matrix::determinate() const
{
    return ul * lr - ll * ur;
}
samurai::Matrix samurai::Matrix::inverse() const
{
    samurai::Matrix inverted(lr, -ll, -ur, ul);
    inverted /= determinate();
    return inverted;
}
samurai::Matrix samurai::Matrix::operator/(const samurai::Matrix& that)
{
    samurai::Matrix result = *this;
    result /= that;
    return result;
}

samurai::Matrix operator*(const samurai::Scalar& scalar,
                          const samurai::Matrix& matrix)
{
    samurai::Matrix result = matrix;
    result *= scalar;
    return result;
}
samurai::Matrix operator*(const samurai::Matrix& matrix,
                          const samurai::Scalar& scalar)
{
    samurai::Matrix result = matrix;
    result *= scalar;
    return result;
}
samurai::Matrix operator/(const samurai::Scalar& scalar,
                          const samurai::Matrix& matrix)
{
    samurai::Matrix result = matrix.inverse();
    result *= scalar;
    return result;
}
samurai::Matrix operator/(const samurai::Matrix& matrix,
                          const samurai::Scalar& scalar)
{
    samurai::Matrix result = matrix;
    result *= scalar;
    return result;
}

samurai::Transform::Transform()
{
}

samurai::Transform::Transform(samurai::Matrix rotation,
                              samurai::Vector translation) :
    rotation(rotation), translation(translation)
{
}

bool samurai::Transform::valid()
{
    return rotation.valid() && translation.valid();
}

samurai::Transform samurai::Transform::inverse() const
{
    samurai::Matrix inverse = rotation.inverse();
    return samurai::Transform(inverse, -inverse * translation);
}
samurai::Transform& samurai::Transform::operator=(
    const samurai::Transform& transform)
{
    rotation = transform.rotation;
    translation = transform.translation;
    return *this;
}
samurai::Vector samurai::Transform::operator()(const samurai::Vector& vector)
{
    return rotation * vector + translation;
}
samurai::Transform samurai::Transform::operator*(
    const samurai::Transform& transform)
{
    samurai::Transform result = *this;
    result *= transform;
    return result;
}
samurai::Transform& samurai::Transform::operator*=(
    const samurai::Transform& transform)
{
    rotation *= transform.rotation;
    translation += transform.translation;
    return *this;
}
samurai::Transform samurai::Transform::operator/(
    const samurai::Transform& transform)
{
    samurai::Transform result = *this;
    result /= transform;
    return result;
}
samurai::Transform& samurai::Transform::operator/=(
    const samurai::Transform& transform)
{
    rotation /= transform.rotation;
    translation -= transform.translation;
    return *this;
}

std::ostream & operator<<(std::ostream & stream,
                          samurai::Vector const & vector)
{
    stream << "(" << vector.x << "," << vector.y << ")";
    return stream;
}
std::ostream & operator<<(std::ostream & stream,
                          samurai::Matrix const & matrix)
{
    stream << "[" << samurai::Vector(matrix.ul, matrix.ll) << ","
    << samurai::Vector(matrix.ur, matrix.lr) << "]";
    return stream;
}
std::ostream & operator<<(std::ostream & stream,
                          samurai::Transform const & transform)
{
    stream << "<" << transform.rotation << "," << transform.translation << ">";
    return stream;
}
